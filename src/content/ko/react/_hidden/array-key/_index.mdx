---
title: Array Key
order: 100
category: hook
isHidden: true
---

two ended optimization GPT ëŒ€ë‹µ - ì˜ˆë¥¼ ë“¤ì–´, [A, B, C]ê°€ [C, A, B]ë¡œ ë³€ê²½ë˜ì—ˆì„ ë•Œ, ì•ì—ì„œë¶€í„° ìˆœíšŒë§Œ í•˜ë©´ ëª¨ë“  ìš”ì†Œë¥¼ moveë¡œ ê°„ì£¼í•˜ê²Œ ë˜ì§€ë§Œ ì•ê³¼ ë’¤ì—ì„œ ë™ì‹œì— ë¹„êµí•˜ë©´ Cê°€ ë’¤ë¡œ ì˜®ê²¨ì¡Œë‹¤ëŠ” ê²ƒì„ ë¹ ë¥´ê²Œ ê°ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

devëª¨ë“œë©´ O(n) ìˆœíšŒë¥¼ í•œ ë²ˆì”© ë” í•˜ë©° ì¤‘ë³µ í‚¤ ê²½ê³ ë¥¼ ì¶œë ¥í•œë‹¤. 

```js
let knownKeys = null;
for (let i = 0; i < newChildren.length; i++) {
const child = newChildren[i];
knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
}
```

í—·ê°ˆë¦¬ëŠ”ë°... Fiber ìì²´ëŠ” ìì‹ ë…¸ë“œë¥¼ ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¡œ ê´€ë¦¬í•˜ì§€ë§Œ JSX?ëŠ” ë°°ì—´ë¡œ childrenì„ ê´€ë¦¬í•œë‹¤. ê·¸ë˜ì„œ reconcileí•  ë•Œë„ ë°°ì—´ë¡œ ì…ë ¥ë°›ìŒ. 

oldFiber: ê½‰ê½‰ ì°¨ìˆìŒ
newChild: ì¤‘ê°„ì— nullì´ ìˆì„ ìˆ˜ ìˆìŒ. isVisible && <Element/> ì´ëŸ°ì‹ìœ¼ë¡œ ì²˜ë¦¬í–ˆë‚˜ë³´ì§€.

This means that, once React finds key mismatch, it will try to â€œmoveâ€ or â€œcreate new fiberâ€.


```js
function reconcileChildrenArray(
    returnFiber: Fiber,
    // [1,2,3,4,5,6]
    currentFirstChild: Fiber | null,
    // [1,6,null,5,4,3]
    newChildren: Array<*>,
    lanes: Lanes,
  ): Fiber | null {
    let resultingFirstChild: Fiber | null = null;
    let previousNewFiber: Fiber | null = null;

    // í˜„ì¬ ë³´ê³ ìˆëŠ” newChildrenì˜ í¬ì¸í„°
    // 1
    let oldFiber = currentFirstChild;
    
    // ë‹¤ìŒ forë¬¸ì—ì„œ ì‚¬ìš©í•  newChildrenì˜ í¬ì¸í„°
    // forë¬¸ ë§ˆì§€ë§‰ì— oldFiber = nextOldFiber; í•´ì¤€ë‹¤.
    let nextOldFiber = null;

    let lastPlacedIndex = 0;
    
    // í˜„ì¬ ì²˜ë¦¬ì¤‘ì¸ newChildrenì˜ ì¸ë±ìŠ¤
    let newIdx = 0;

    // ì¼ì¢…ì˜ íˆ¬í¬ì¸í„° ì•Œê³ ë¦¬ì¦˜
    // ë‘ ì •ë ¬ëœ ë°°ì—´ì„ í•©ì¹˜ëŠ” ì½”í…Œ ë¬¸ì œë¥¼ ìƒê°í•˜ì. 
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      // index might not be exactly its position????
      if (oldFiber.index > newIdx) {
        // ??????
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      
      // newChildren[newIdx]ë¥¼ ë‚˜íƒ€ë‚´ëŠ” Fiber ìƒì„±
      // null, undefined ìš”ì†Œë©´ newFiberê°€ nullì´ë‹¤.
      const newFiber = ... 

      if (newFiber === null) {
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }

      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    // forë¬¸ ë

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      if (getIsHydrating()) {
        const numberOfForks = newIdx;
        pushTreeFork(returnFiber, numberOfForks);
      }
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
        if (newFiber === null) {
          continue;
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
      if (getIsHydrating()) {
        const numberOfForks = newIdx;
        pushTreeFork(returnFiber, numberOfForks);
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      const newFiber = updateFromMap(
        existingChildren,
        returnFiber,
        newIdx,
        newChildren[newIdx],
        lanes,
      );
      if (newFiber !== null) {
        if (shouldTrackSideEffects) {
          if (newFiber.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(
              newFiber.key === null ? newIdx : newFiber.key,
            );
          }
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
    }

    return resultingFirstChild;
  }
```
ğŸ’¡ ì „ì œ: `oldFiber.index` ì™€ `newIdx` ê°€ ì˜ë¯¸í•˜ëŠ” ê²ƒ

| ê°’ | ì˜ë¯¸ |
|----|------|
| `oldFiber.index` | ê¸°ì¡´ Fiber íŠ¸ë¦¬ì—ì„œì˜ ìˆœì„œ (Reactê°€ ë Œë”ë§ ì‹œ í• ë‹¹í•œ index) |
| `newIdx` | `newChildren` ë°°ì—´ì—ì„œì˜ í˜„ì¬ ìˆœì„œ (ìƒˆë¡­ê²Œ ë Œë”ë§ëœ ìˆœì„œ) |

ì¦‰, ë‘˜ì„ ë¹„êµí•˜ë©´ "ê¸°ì¡´ ìˆœì„œ"ì™€ "ìƒˆ ìˆœì„œ" ê°„ì˜ ì°¨ì´ë¥¼ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ğŸ” ì½”ë“œ ë¸”ë¡ ë¶„ì„

```js
if (oldFiber.index > newIdx) {
  nextOldFiber = oldFiber;
  oldFiber = null;
} else {
  nextOldFiber = oldFiber.sibling;
}
```

ì´ ë¡œì§ì€ Fiber ê°„ ìˆœì„œ ì—­ì „ (out-of-order) ì„ ê°ì§€í•˜ê³ , ì •ë ¬ëœ ë¹„êµë¥¼ ìœ ì§€í•˜ê¸° ìœ„í•œ ê²ƒì…ë‹ˆë‹¤.

ğŸ“Œ ê°ê°ì˜ ê²½ìš° ì„¤ëª…

âœ… oldFiber.index &lt;= newIdx (ì •ìƒ ìˆœì„œ)

nextOldFiber = oldFiber.sibling;

	â€¢	í˜„ì¬ oldFiberëŠ” newIdxì™€ ìˆœì„œìƒ ì¼ì¹˜í•˜ê±°ë‚˜ ì•ì— ìˆìŒ â†’ ì •ìƒ ìˆœì„œë¡œ ê°„ì£¼.
	â€¢	ë‹¤ìŒ ìˆœíšŒ ì‹œì— oldFiber.siblingì„ ë¹„êµ ëŒ€ìƒìœ¼ë¡œ ì‚¬ìš©í•˜ë„ë¡ nextOldFiberì— ì €ì¥í•¨.
	â€¢	ì¦‰, oldFiberë¥¼ ê³„ì† ì•ìœ¼ë¡œ ì „ì§„í•˜ë©° newChildrenê³¼ ë‚˜ë€íˆ ë¹„êµí•  ìˆ˜ ìˆìŒ.

âŒ oldFiber.index > newIdx (ì—­ì „ ë°œìƒ)

nextOldFiber = oldFiber;
oldFiber = null;

	â€¢	í˜„ì¬ oldFiberì˜ ìˆœì„œê°€ newIdxë³´ë‹¤ ë’¤ì— ìˆìŒ â†’ ìˆœì„œê°€ í‹€ë¦¼!
	â€¢	ì¦‰, í˜„ì¬ newChildì— í•´ë‹¹í•˜ëŠ” oldFiberëŠ” ì—†ëŠ” ê²ƒìœ¼ë¡œ íŒë‹¨.
	â€¢	oldFiberë¥¼ nullë¡œ ì„¤ì •í•˜ì—¬ í•´ë‹¹ newChildren[newIdx] ì— ëŒ€í•´ ìƒˆë¡œ ìƒì„±(create) ë¡œì§ì„ ìœ ë„í•¨.
	â€¢	í•˜ì§€ë§Œ nextOldFiberëŠ” ê·¸ëŒ€ë¡œ oldFiberë¡œ ìœ ì§€ â†’ ì´í›„ ë£¨í”„ì—ì„œ ë‹¤ì‹œ oldFiberë¡œ ì‚¬ìš© ê°€ëŠ¥

ì´ë ‡ê²Œ í•¨ìœ¼ë¡œì¨:
	â€¢	Fiber ìˆœì„œê°€ ì§€ì¼œì§€ëŠ” í•œ ë¹ ë¥´ê²Œ ì§„í–‰í•˜ê³ ,
	â€¢	ìˆœì„œê°€ ê¼¬ì´ë©´ ê¸°ì¡´ Fiberë¥¼ ì¼ì‹œì ìœ¼ë¡œ ë¬´ì‹œí•˜ê³ , ìƒˆ Fiberë¥¼ ìƒì„±í•˜ê±°ë‚˜ Map ê¸°ë°˜ ë¹„êµë¡œ ë„˜ì–´ê°€ëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤.

ğŸ¤” ì™œ ì´ëŸ° ì²˜ë¦¬ë¥¼ í• ê¹Œ?

ReactëŠ” ê°€ëŠ¥í•œ í•œ ê¸°ì¡´ Fiberë¥¼ ì¬ì‚¬ìš©í•˜ì—¬ ì„±ëŠ¥ì„ ë†’ì´ë ¤ í•©ë‹ˆë‹¤. ì´ë•Œ FiberëŠ” ì—°ê²° ë¦¬ìŠ¤íŠ¸ í˜•íƒœì´ê³ , ì—­ë°©í–¥ í¬ì¸í„°(back pointer)ê°€ ì—†ê¸° ë•Œë¬¸ì— ì–‘ìª½ì—ì„œ ë™ì‹œì— íƒìƒ‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

ê·¸ë˜ì„œ ë‹¤ìŒê³¼ ê°™ì€ ì „ëµì„ ì”ë‹ˆë‹¤:
	1.	ê°€ëŠ¥í•œ ê²½ìš° í•œ ë°©í–¥ìœ¼ë¡œ ìˆœì„œëŒ€ë¡œ ë¹„êµí•˜ë©° ì¬ì‚¬ìš©
	2.	ìˆœì„œê°€ ì–´ê¸‹ë‚˜ëŠ” ìˆœê°„, oldFiberë¥¼ nullë¡œ ë‘ì–´ â€œìƒˆ Fiberë¥¼ ë§Œë“¤ë„ë¡â€ ìœ ë„
	3.	ì´í›„ í•„ìš”í•˜ë©´ Map ê¸°ë°˜ ë¹„êµ ë¡œì§ìœ¼ë¡œ fallback

ì´ ì²˜ë¦¬ëŠ” íŠ¹íˆ ë‹¤ìŒê³¼ ê°™ì€ ìƒí™©ì—ì„œ ì¤‘ìš”í•©ë‹ˆë‹¤:

```jsx
<ul>
  <li key="A" />
  <li key="B" />
  <li key="C" />
</ul>

// â†’ ìˆœì„œ ë³€ê²½
<ul>
  <li key="C" />
  <li key="A" />
  <li key="B" />
</ul>
```

ì´ë ‡ê²Œ ìˆœì„œê°€ ë’¤ë°”ë€Œë©´ index ê¸°ì¤€ ë¹„êµë¡œëŠ” ë¬¸ì œê°€ ìƒê¸°ê¸° ë•Œë¬¸ì—, ì´ ì¡°ê±´ë¬¸ì„ í†µí•´ â€œìˆœì„œ ì—­ì „â€ì„ ê°ì§€í•˜ê³  ì²˜ë¦¬ ë°©í–¥ì„ ë°”ê¿‰ë‹ˆë‹¤.

âœ… ì •ë¦¬

ì¡°ê±´	ì˜ë¯¸	ì²˜ë¦¬ ë°©ì‹
oldFiber.index &lt;= newIdx	oldFiberê°€ ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì— ìˆìŒ	ë¹„êµ í›„ ë‹¤ìŒ siblingìœ¼ë¡œ ì§„í–‰
oldFiber.index > newIdx	oldFiberì˜ ìœ„ì¹˜ê°€ ë’¤ì— ìˆìŒ (ìˆœì„œ ì–´ê¸‹ë‚¨)	ì¬ì‚¬ìš©í•˜ì§€ ì•Šê³ , newChildëŠ” ìƒˆë¡œ ìƒì„± ìœ ë„

ì´ ì¡°ê±´ë¬¸ ë•ë¶„ì— ReactëŠ” ìµœì†Œí•œì˜ ë³€ê²½ë§Œì„ ê°ì§€í•˜ê³  ìˆ˜í–‰í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë™ì‘í•˜ë©°, ëŒ€ë¶€ë¶„ì˜ UI ì—…ë°ì´íŠ¸ì—ì„œ ì„±ëŠ¥ì„ ê·¹ëŒ€í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ğŸ“Œ ì°¸ê³ 

í•„ìš”í•˜ì‹œë‹¤ë©´ ì´ ë‹¤ìŒì— ì´ì–´ì§€ëŠ” updateSlotê³¼ placeChildë„ ê°™ì´ í•´ì„í•´ë“œë¦´ ìˆ˜ ìˆì–´ìš”.