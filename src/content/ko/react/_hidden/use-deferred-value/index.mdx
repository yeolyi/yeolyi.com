---
title: useDeferredValue
order: 101
category: hook
isHidden: true
---

## 복습

새 콘텐츠가 로딩되는 동안 오래된 콘텐츠 표시하기 
컴포넌트의 최상위 레벨에서 useDeferredValue를 호출하여 UI 일부 업데이트를 지연할 수 있습니다.

```js
function App() {
  const [text, setText] = useState('');
  const deferredText = useDeferredValue(text);
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <SlowList text={deferredText} />
    </>
  );
}
```

## 구현

useTransition과 동일하게 setState의 우선순위 플래그를 바꾼다. 

ReactFiberWorkLoop의 requestUpdateLane를 보면 Transition 유무에 따라 다른 lane을 받는 것 같다. 

```js
const isTransition = requestCurrentTransition() !== NoTransition;
if (isTransition) {
if (__DEV__ && ReactCurrentBatchConfig.transition !== null) {
    const transition = ReactCurrentBatchConfig.transition;
    if (!transition._updatedFibers) {
    transition._updatedFibers = new Set();
    }

    transition._updatedFibers.add(fiber);
}
// The algorithm for assigning an update to a lane should be stable for all
// updates at the same priority within the same event. To do this, the
// inputs to the algorithm must be the same.
//
// The trick we use is to cache the first of each of these inputs within an
// event. Then reset the cached values once we can be sure the event is
// over. Our heuristic for that is whenever we enter a concurrent work loop.
if (currentEventTransitionLane === NoLane) {
    // All transitions within the same event are assigned the same lane.
    currentEventTransitionLane = claimNextTransitionLane();
}
return currentEventTransitionLane;
}
```

```js
export type BatchConfigTransition = {
  name?: string,
  startTime?: number,
  _updatedFibers?: Set<Fiber>,
};
```

## ??

내가 생각한 `useDeferredValue`의 예제와 저자가 제시한게 다르다. 렌더링 관련이지 네트워크 관련은 아니지 않나...? 예제 코드를 뜯어보자.

```js
function fetchProfileData(userId) {
  let userPromise = fetchUser(userId);
  let postsPromise = fetchPosts(userId);
  return {
    userId,
    user: wrapPromise(userPromise),
    posts: wrapPromise(postsPromise),
  };
}

// Suspense integrations like Relay implement
// a contract like this to integrate with React.
// Real implementations can be significantly more complex.
// Don't copy-paste this into your project!
function wrapPromise(promise) {
  let status = "pending";
  let result;
  let suspender = promise.then(
    (r) => {
      status = "success";
      result = r;
    },
    (e) => {
      status = "error";
      result = e;
    },
  );
  return {
    read() {
      if (status === "pending") {
        throw suspender;
      } else if (status === "error") {
        throw result;
      } else if (status === "success") {
        return result;
      }
    },
  };
}

function fetchUser(userId) {
  // 300ms 후에 반환하는 프로미스   
}

function fetchPosts(userId) {
  // 1000ms 후에 반환하는 프로미스
}

function getNextId(id) {
  return id === 3 ? 0 : id + 1;
}

const initialResource = fetchProfileData(0);

function App() {
  const [resource, setResource] = React.useState(initialResource);
  const [isPending, startTransition] = React.useTransition({
    timeoutMs: 3000,
  });
  return (
    <React.Fragment>
      <button
        disabled={!!isPending}
        onClick={() => {
          startTransition(() => {
            const nextUserId = getNextId(resource.userId);
            setResource(fetchProfileData(nextUserId));
          });
        }}
      >
        Next
      </button>
      {isPending ? " Loading..." : null}
      <ProfilePage resource={resource} />
    </React.Fragment>
  );
}

function ProfilePage({ resource }) {
  return (
    <React.Suspense fallback={<h1>Loading profile...</h1>}>
      <ProfileDetails resource={resource} />
      <React.Suspense fallback={<h1>Loading posts...</h1>}>
        <ProfileTimeline resource={resource} />
      </React.Suspense>
    </React.Suspense>
  );
}

function ProfileDetails({ resource }) {
  const user = resource.user.read();
  return <h1>{user.name}</h1>;
}

function ProfileTimeline({ resource, isStale }) {
  const posts = resource.posts.read();
  return (
    <ul style={{ opacity: isStale ? 0.7 : 1 }}>
      {posts.map((post) => (
        <li key={post.id}>{post.text}</li>
      ))}
    </ul>
  );
}

const rootElement = document.getElementById("container");
ReactDOM.createRoot(rootElement).render(<App />);
```

예시가 안되는데요...

```js
export type BatchConfigTransition = {
  name?: string,
  startTime?: number,
  _updatedFibers?: Set<Fiber>,
};
```
